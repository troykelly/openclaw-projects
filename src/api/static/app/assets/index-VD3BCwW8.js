import{r as a,x as w,R,j as M}from"./index-dxUAcY-k.js";import{h as y,a as P,f as N}from"./index-6gjEHE0t.js";import{u as g}from"./button-BqoICpPk.js";var _=w[" useId ".trim().toString()]||(()=>{}),$=0;function q(e){const[t,o]=a.useState(_());return y(()=>{o(l=>l??String($++))},[e]),e||(t?`radix-${t}`:"")}var j=w[" useInsertionEffect ".trim().toString()]||y;function F({prop:e,defaultProp:t,onChange:o=()=>{},caller:l}){const[d,r,S]=L({defaultProp:t,onChange:o}),n=e!==void 0,x=n?e:d;{const c=a.useRef(e!==void 0);a.useEffect(()=>{const i=c.current;i!==n&&console.warn(`${l} is changing from ${i?"controlled":"uncontrolled"} to ${n?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),c.current=n},[n,l])}const I=a.useCallback(c=>{if(n){const i=b(c)?c(e):c;i!==e&&S.current?.(i)}else r(c)},[n,e,r,S]);return[x,I]}function L({defaultProp:e,onChange:t}){const[o,l]=a.useState(e),d=a.useRef(o),r=a.useRef(t);return j(()=>{r.current=t},[t]),a.useEffect(()=>{d.current!==o&&(r.current?.(o),d.current=o)},[o,d]),[o,l,r]}function b(e){return typeof e=="function"}function V(e){const t=e+"CollectionProvider",[o,l]=P(t),[d,r]=o(t,{collectionRef:{current:null},itemMap:new Map}),S=m=>{const{scope:s,children:p}=m,u=R.useRef(null),f=R.useRef(new Map).current;return M.jsx(d,{scope:s,itemMap:f,collectionRef:u,children:p})};S.displayName=t;const n=e+"CollectionSlot",x=N(n),I=R.forwardRef((m,s)=>{const{scope:p,children:u}=m,f=r(n,p),C=g(s,f.collectionRef);return M.jsx(x,{ref:C,children:u})});I.displayName=n;const c=e+"CollectionItemSlot",i="data-radix-collection-item",h=N(c),E=R.forwardRef((m,s)=>{const{scope:p,children:u,...f}=m,C=R.useRef(null),A=g(s,C),v=r(c,p);return R.useEffect(()=>(v.itemMap.set(C,{ref:C,...f}),()=>{v.itemMap.delete(C)})),M.jsx(h,{[i]:"",ref:A,children:u})});E.displayName=c;function T(m){const s=r(e+"CollectionConsumer",m);return R.useCallback(()=>{const u=s.collectionRef.current;if(!u)return[];const f=Array.from(u.querySelectorAll(`[${i}]`));return Array.from(s.itemMap.values()).sort((v,O)=>f.indexOf(v.ref.current)-f.indexOf(O.ref.current))},[s.collectionRef,s.itemMap])}return[{Provider:S,Slot:I,ItemSlot:E},T,l]}export{F as a,V as c,q as u};
//# sourceMappingURL=index-VD3BCwW8.js.map
